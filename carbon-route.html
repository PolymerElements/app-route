<!--
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<script>
  'use strict';

  Polymer({
    is: 'carbon-route',

    properties: {
      /**
       * The URL component managed by this element.
       */
      route: {
        type: Object,
        notify: true
      },

      /**
       * The pattern to match `path` against.
       *
       * Path values like `:named` become pseudo-properties of the same name
       * on this element.
       */
      match: {
        type: String
      },

      /**
       * The parameterized values that are extracted from the route as
       * described by match.
       */
      data: {
        type: Object,
        value: function() {return {};},
        notify: true
      },

      /**
       * The part of `path` NOT consumed by `match`.
       * Equivalent to `path.substring(matched.length + 1)`
       */
      tail: {
        type: Object,
        value: function() {return {path: null, prefix: null, queryParams: null};},
        notify: true
      },

      _skipMatch: {
        value: false
      },
      _matched: {
        value: ''
      }
    },

    observers: [
      '__tryToMatch(route.path, match)',
      '__updatePathOnDataChange(data.*)',
      '__tailChanged(tail.path)'
    ],

    __tryToMatch: function(path, match) {
      if (this._skipMatch || !path) {
        return;
      }

      var matchResult = this.matchPath(path, match);
      if (matchResult == null) {
        this._matched = null;
        // this.tail = null;
        // this.data = ???;
        return;
      }

      this._skipMatch = true;
      this._matched = matchResult.matched;
      this.data = matchResult.data;
      var newTail = matchResult.tail;

      if (!this.tail || this.tail.prefix !== newTail.prefix || this.tail.path !== newTail.prefix) {
        newTail.queryParams = newTail.queryParams || this.route.queryParams;
        this.tail = newTail;
      }
      this._skipMatch = false;
    },

    matchPath: function(path, match) {
      if (!match) {
        return;
      }
      var remainingPieces = path.split('/');
      var matchPieces = match.split('/');

      var matched = [];
      var namedMatches = {};

      for (var i=0; i < matchPieces.length; i++) {
        var matchPiece = matchPieces[i];
        if (!matchPiece && matchPiece !== '') {
          break;
        }
        var pathPiece = remainingPieces.shift();

        // We don't match this path.
        if (!pathPiece && pathPiece !== '') {
          return;
        }
        matched.push(pathPiece);

        if (matchPiece.charAt(0) == ':') {
          namedMatches[matchPiece.slice(1)] = pathPiece;
        } else if (matchPiece !== pathPiece) {
          return;
        }
      }

      var matchedString = matched.join('/');

      var tailPath = remainingPieces.join('/');
      if (remainingPieces.length > 0) {
        tailPath = '/' + tailPath;
      }
      var tailPrefix = this.route.prefix + matchedString;

      return {
        data: namedMatches,
        matched: matched.join('/'),
        tail: {
          prefix: tailPrefix,
          path: tailPath,
          queryParams: this.route.queryParams
        }
      }
    },

    __tailChanged: function(path) {
      if (!this._matched || this._skipMatch) {
        return;
      }
      var newPath = this._matched;
      if (path) {
        if (path.charAt(0) !== '/') {
          path = '/' + path;
        }
        newPath += path;
      }
      this.set('route.path', newPath);
    },

    __updatePathOnDataChange: function() {
      if (!this.route || this._skipMatch || !this._matched) {
        return;
      }
      this._skipMatch = true;
      this.tail = {path: null, prefix: null, queryParams: null};
      this.set('route.path', this.__getLink({}));
      this._skipMatch = false;
    },

    __getLink: function(overrideValues) {
      var values = {tail: this.tail};
      for (var key in this.data) {
        values[key] = this.data[key];
      }
      for (var key in overrideValues) {
        values[key] = overrideValues[key];
      }
      var matchPieces = this.match.split('/');
      var interp = matchPieces.map(function(value) {
        if (value[0] == ':') {
          value = values[value.slice(1)];
        }
        return value;
      }, this);
      if (values.tail && values.tail.path) {
        interp.push(values.tail.path);
      }
      return interp.join('/');
    }
  });
</script>
